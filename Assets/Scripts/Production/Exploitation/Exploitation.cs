using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Exploitation : MonoBehaviour
{
    public Expedition expedition;
    [SerializeField] private GameObject slot;
    private TuileManager tuileExploitee;
    private float profondeur = -3.9f;
    public List<SlotExploit> listeSlots = new List<SlotExploit>();
    [SerializeField] private GameObject panelGainRessource;
    [SerializeField] private GameObject panelGainXP;
    private Production gainRessource;

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
    private void OnEnable()
    {
        MisaAJourSlots();
    }

    private void OnDestroy()
    {
        expedition.tribu.stockRessources.RetirerGain(GainRessource);
    }

    private void MisaAJourSlots()
    {
        if(tuileExploitee)
        {
            if (tuileExploitee.productionTuile.nbrSlot != listeSlots.Count)
            {
                
                GenererSlots(tuileExploitee.productionTuile.nbrSlot - listeSlots.Count);
            }
        }
    }

    //Fait office d'initialisateur
    public TuileManager TuileExploitee
    {
        set
        {
            tuileExploitee = value;
            Vector3 position = tuileExploitee.transform.position;
            position.z = profondeur;
            transform.position = position;
            expedition.tribu.stockRessources.AjouterGain(GainRessource);
            GenererSlots();

        }
    }

    private void GenererSlots()
    {
        if (expedition.tribu.tuileActuelle != tuileExploitee)
        {
            int nbrSlots = tuileExploitee.productionTuile.nbrSlot;
            for (int i = 0; i < nbrSlots; i++)
            {
                GameObject nvSlot = Instantiate(slot, transform);
                SlotExploit slotExploit = nvSlot.GetComponent<SlotExploit>();
                listeSlots.Add(slotExploit);
                slotExploit.exploitation = this;
            }
            RearangerSlots();
        }
    }

    private void GenererSlots(int nbrSlots)
    {
        if (expedition.tribu.tuileActuelle != tuileExploitee)
        {
            if (nbrSlots > 0) //si le nobre de slots à rajouter est positif, on instantie ces slots
            {
                for (int i = 0; i < nbrSlots; i++)
                {
                    GameObject nvSlot = Instantiate(slot, transform);
                    SlotExploit slotExploit = nvSlot.GetComponent<SlotExploit>();
                    listeSlots.Add(slotExploit);
                    slotExploit.exploitation = this;
                }
            }
            else //sinon on supprime des slots
            {
                print("nbr slot : " + nbrSlots);
                for (int i = 0; i < Math.Abs(nbrSlots); i++)
                {
                    if(listeSlots.Count > 1)
                    {
                        Destroy(listeSlots[listeSlots.Count - 1].gameObject);
                        listeSlots.RemoveAt(listeSlots.Count - 1);
                    }
                    else
                    {
                        Destroy(listeSlots[0].gameObject);
                        listeSlots.RemoveAt(0);
                    }
                }
            }
            RearangerSlots();
        }
    }

    private void RearangerSlots()
    {
        int nbrSlots = listeSlots.Count;
        float largeurSlot = slot.GetComponent<SpriteRenderer>().bounds.size.x;
        float espaceSepration = 0.025f;
        int degreAxeY = nbrSlots / 3;

        int colonnes = (nbrSlots - 1) % 3;
        if (nbrSlots > 3) colonnes = 2;

        float positionX = (largeurSlot / 2 * colonnes) + (espaceSepration * colonnes);
        float positionY = (largeurSlot * (degreAxeY)) - (espaceSepration * degreAxeY);

        Vector3 decalage = new Vector3();

        for (int i = 0; i < nbrSlots; i++)
        {
            SlotExploit slotExploit = listeSlots[i];

            decalage.x = -largeurSlot * (i % 3) - espaceSepration * (i % 3) + positionX;
            decalage.y = -largeurSlot * (i / 3) - espaceSepration * (i / 3) + positionY;

            slotExploit.transform.position += decalage;
        }

        foreach(SlotExploit slot in listeSlots)
        {
            if(slot.pop != null)
            {
                slot.RecentrerPop();
            }
        }
    }

    public void AfficherGainRessource()
    {
        panelGainRessource.GetComponent<PanelGainRessources>().AfficherRessources(GainRessource);
        expedition.tribu.stockRessources.AjouterGain(GainRessource);
    }

    private Production GainRessource
    {
        get
        {
            if(gainRessource == null)
            {
                gainRessource = ScriptableObject.CreateInstance<Production>();
                gainRessource.gains = new float[ListeRessources.Defaut.listeDesRessources.Length];
            }
            gainRessource.Clear();
            if (tuileExploitee != expedition.tribu.tuileActuelle)
            {
                int slotsOccupes = 0;
                foreach (SlotExploit slot in listeSlots)
                {
                    if (slot.pop != null)
                    {
                        slotsOccupes++;
                    }
                }
                for (int i = 0; i < gainRessource.gains.Length; i++)
                {
                    gainRessource.gains[i] += tuileExploitee.productionTuile.production.gains[i] * slotsOccupes;
                }
                return gainRessource;
            }
            else
            {
                for (int i = 0; i < gainRessource.gains.Length; i++)
                {
                    gainRessource.gains[i] += tuileExploitee.productionTuile.production.gains[i];
                }
                return gainRessource;
            }
        }
    }
}
