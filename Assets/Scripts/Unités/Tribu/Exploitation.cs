using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Exploitation : MonoBehaviour
{
    public Expedition expedition;
    [SerializeField] private GameObject slot;
    private TuileManager tuileExploitee;
    private float profondeur = -4;
    public List<SlotExploit> listeSlots = new List<SlotExploit>();
    private StockRessource stockRessource;
    [SerializeField] private GameObject panelGainRessource;
    [SerializeField] private GameObject panelGainXP;

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    //Fait office d'initialisateur
    public TuileManager TuileExploitee
    {
        set
        {
            stockRessource = expedition.tribu.stockRessources;

            tuileExploitee = value;
            Vector3 position = tuileExploitee.transform.position;
            position.z = profondeur;
            transform.position = position;

            if(expedition.tribu.tuileActuelle != tuileExploitee)
            {
                Invoke("GenererSlots",0.1f);
            }
        }
    }

    private void GenererSlots()
    {
        int nbrSlots = tuileExploitee.productionTuile.prod.slots;
        float largeurSlot = slot.GetComponent<SpriteRenderer>().bounds.size.x;
        float espaceSepration = 0.025f;
        int degreAxeY = nbrSlots / 3;

        int colonnes = (nbrSlots -1) % 3;
        if (nbrSlots > 3) colonnes = 2;

        float positionX = (largeurSlot / 2 * colonnes) + (espaceSepration * colonnes);
        float positionY = (largeurSlot * (degreAxeY)) - (espaceSepration * degreAxeY);

        Vector3 decalage = new Vector3();

        for (int i = 0; i < nbrSlots; i++)
        {
            GameObject nvSlot = Instantiate(slot, transform);
            SlotExploit slotExploit = nvSlot.GetComponent<SlotExploit>();
            listeSlots.Add(slotExploit);
            slotExploit.exploitation = this;

            decalage.x = -largeurSlot * (i % 3) - espaceSepration * (i % 3) + positionX;
            decalage.y = -largeurSlot * (i / 3) - espaceSepration * (i / 3) + positionY;

            nvSlot.transform.position += decalage;
        }
    }

    public void AfficherGainRessource()
    {
        panelGainRessource.GetComponent<PanelGainRessources>().afficherRessources(GainRessource);
    }

    private ProductionTuile.Production GainRessource
    {
        get
        {
            if (tuileExploitee != expedition.tribu.tuileActuelle)
            {
                int slotsOccupes = 0;
                foreach (SlotExploit slot in listeSlots)
                {
                    if (slot.pop != null)
                    {
                        slotsOccupes++;
                    }
                }
                return tuileExploitee.productionTuile.prod * slotsOccupes;
            
            }
            else
            {
                return tuileExploitee.productionTuile.prod;
            }
        }
    }
}
